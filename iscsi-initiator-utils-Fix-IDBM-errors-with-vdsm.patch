From 3214c734899e12e01eaa080cdc2dac41927663b0 Mon Sep 17 00:00:00 2001
From: Chris Leech <cleech@redhat.com>
Date: Tue, 13 Aug 2013 10:59:44 -0700
Subject: [PATCH] Fix IDBM errors with vdsm

idbm_rec_write, check for tpgt first

Factor out the check for a tpgt to a single place, before going crazy on
the rec files.  Makes flow of this function easier to follow, and preps
for splitting it up.

idbm_rec_write, seperate old and new style writes

Duplicates a small bit of code, but easier to understand and extened.

idbw_rec_write, pick tpgt from existing record

On a static add (-m node -o new) without a user specified tpgt, looks
for existing new style records with tpgt before creating an old style
record without.  If one exists, take the tpgt from it an write an
updated new style record instead.
---
 usr/idbm.c | 166 ++++++++++++++++++++++++++++++++++++++++++++-----------------
 1 file changed, 120 insertions(+), 46 deletions(-)

diff --git a/usr/idbm.c b/usr/idbm.c
index dacf028..530b29f 100644
--- a/usr/idbm.c
+++ b/usr/idbm.c
@@ -27,6 +27,7 @@
 #include <errno.h>
 #include <dirent.h>
 #include <limits.h>
+#include <glob.h>
 #include <sys/stat.h>
 #include <sys/file.h>
 
@@ -162,6 +163,8 @@ static struct idbm *db;
 	_n++; \
 } while(0)
 
+static int idbm_remove_disc_to_node_link(node_rec_t *rec, char *portal);
+
 static void
 idbm_recinfo_discovery(discovery_rec_t *r, recinfo_t *ri)
 {
@@ -1812,7 +1815,7 @@ mkdir_portal:
 	return f;
 }
 
-static int idbm_rec_write(node_rec_t *rec)
+static int idbm_rec_write_new(node_rec_t *rec)
 {
 	struct stat statb;
 	FILE *f;
@@ -1824,34 +1827,8 @@ static int idbm_rec_write(node_rec_t *rec)
 		log_error("Could not alloc portal\n");
 		return ISCSI_ERR_NOMEM;
 	}
-
-	snprintf(portal, PATH_MAX, "%s", NODE_CONFIG_DIR);
-	if (access(portal, F_OK) != 0) {
-		if (mkdir(portal, 0660) != 0) {
-			log_error("Could not make %s: %s\n", portal,
-				  strerror(errno));
-			rc = ISCSI_ERR_IDBM;
-			goto free_portal;
-		}
-	}
-
-	snprintf(portal, PATH_MAX, "%s/%s", NODE_CONFIG_DIR, rec->name);
-	if (access(portal, F_OK) != 0) {
-		if (mkdir(portal, 0660) != 0) {
-			log_error("Could not make %s: %s\n", portal,
-				  strerror(errno));
-			rc = ISCSI_ERR_IDBM;
-			goto free_portal;
-		}
-	}
-
 	snprintf(portal, PATH_MAX, "%s/%s/%s,%d", NODE_CONFIG_DIR,
 		 rec->name, rec->conn[0].address, rec->conn[0].port);
-	log_debug(5, "Looking for config file %s", portal);
-
-	rc = idbm_lock();
-	if (rc)
-		goto free_portal;
 
 	rc = stat(portal, &statb);
 	if (rc) {
@@ -1861,34 +1838,22 @@ static int idbm_rec_write(node_rec_t *rec)
 		 * set the tgpt. In new versions you must pass all the info in
 		 * from the start
 		 */
-		if (rec->tpgt == PORTAL_GROUP_TAG_UNKNOWN)
-			/* drop down to old style portal as config */
-			goto open_conf;
-		else
-			goto mkdir_portal;
+		goto mkdir_portal;
 	}
 
 	if (!S_ISDIR(statb.st_mode)) {
 		/*
-		 * older iscsiadm versions had you create the config then set
-		 * set the tgpt. In new versions you must pass all the info in
-		 * from the start
-		 */
-		if (rec->tpgt == PORTAL_GROUP_TAG_UNKNOWN)
-			/* drop down to old style portal as config */
-			goto open_conf;
-		/*
 		 * Old style portal as a file, but with tpgt. Let's update it.
 		 */
 		if (unlink(portal)) {
 			log_error("Could not convert %s: %s\n", portal,
 				  strerror(errno));
 			rc = ISCSI_ERR_IDBM;
-			goto unlock;
+			goto free_portal;
 		}
 	} else {
 		rc = ISCSI_ERR_INVAL;
-		goto unlock;
+		goto free_portal;
 	}	
 
 mkdir_portal:
@@ -1899,24 +1864,133 @@ mkdir_portal:
 			log_error("Could not make dir %s: %s\n",
 				  portal, strerror(errno));
 			rc = ISCSI_ERR_IDBM;
-			goto unlock;
+			goto free_portal;
 		}
 	}
 
 	snprintf(portal, PATH_MAX, "%s/%s/%s,%d,%d/%s", NODE_CONFIG_DIR,
 		 rec->name, rec->conn[0].address, rec->conn[0].port, rec->tpgt,
 		 rec->iface.name);
-open_conf:
+/* open_conf: */
 	f = fopen(portal, "w");
 	if (!f) {
 		log_error("Could not open %s: %sd\n", portal, strerror(errno));
 		rc = ISCSI_ERR_IDBM;
-		goto unlock;
+		goto free_portal;
 	}
 
 	idbm_print(IDBM_PRINT_TYPE_NODE, rec, 1, f);
 	fclose(f);
-unlock:
+free_portal:
+	free(portal);
+	return rc;
+}
+
+static int idbm_rec_write_old(node_rec_t *rec)
+{
+	FILE *f;
+	char *portal;
+	int rc = 0;
+	glob_t globbuf;
+	int i;
+	int tpgt = PORTAL_GROUP_TAG_UNKNOWN;
+
+	portal = malloc(PATH_MAX);
+	if (!portal) {
+		log_error("Could not alloc portal\n");
+		return ISCSI_ERR_NOMEM;
+	}
+
+	/* check for newer portal dir with tpgt */
+	snprintf(portal, PATH_MAX, "%s/%s/%s,%d,*", NODE_CONFIG_DIR,
+		 rec->name, rec->conn[0].address, rec->conn[0].port);
+	rc = glob(portal, GLOB_ONLYDIR, NULL, &globbuf);
+	if (!rc) {
+		if (globbuf.gl_pathc > 1)
+			log_warning("multiple tpg records for portal "
+				    "%s/%s:%d found", rec->name,
+				    rec->conn[0].address, rec->conn[0].port);
+		/* set pattern for sscanf matching of tpgt */
+		snprintf(portal, PATH_MAX, "%s/%s/%s,%d,%%u", NODE_CONFIG_DIR,
+			 rec->name, rec->conn[0].address, rec->conn[0].port);
+		for (i = 0; i < globbuf.gl_pathc; i++) {
+			rc = sscanf(globbuf.gl_pathv[i], portal, &tpgt);
+			if (rc == 1)
+				break;
+		}
+		if (tpgt == PORTAL_GROUP_TAG_UNKNOWN)
+			log_warning("glob match on existing records, "
+				    "but no valid tpgt found");
+	}
+	globfree(&globbuf);
+	rc = 0;
+
+	/* if a tpgt was selected from an old record, write entry in new format */
+	if (tpgt != PORTAL_GROUP_TAG_UNKNOWN) {
+		log_warning("using tpgt %u from existing record", tpgt);
+		rec->tpgt = tpgt;
+		rc = idbm_remove_disc_to_node_link(rec, portal);
+		free(portal);
+		return idbm_rec_write_new(rec);
+	}
+
+	snprintf(portal, PATH_MAX, "%s/%s/%s,%d", NODE_CONFIG_DIR,
+		 rec->name, rec->conn[0].address, rec->conn[0].port);
+
+	f = fopen(portal, "w");
+	if (!f) {
+		log_error("Could not open %s: %sd\n", portal, strerror(errno));
+		rc = ISCSI_ERR_IDBM;
+		goto free_portal;
+	}
+	idbm_print(IDBM_PRINT_TYPE_NODE, rec, 1, f);
+	fclose(f);
+free_portal:
+	free(portal);
+	return rc;
+}
+
+static int idbm_rec_write(node_rec_t *rec)
+{
+	char *portal;
+	int rc = 0;
+
+	portal = malloc(PATH_MAX);
+	if (!portal) {
+		log_error("Could not alloc portal\n");
+		return ISCSI_ERR_NOMEM;
+	}
+
+	snprintf(portal, PATH_MAX, "%s", NODE_CONFIG_DIR);
+	if (access(portal, F_OK) != 0) {
+		if (mkdir(portal, 0660) != 0) {
+			log_error("Could not make %s: %s\n", portal,
+				  strerror(errno));
+			rc = ISCSI_ERR_IDBM;
+			goto free_portal;
+		}
+	}
+
+	snprintf(portal, PATH_MAX, "%s/%s", NODE_CONFIG_DIR, rec->name);
+	if (access(portal, F_OK) != 0) {
+		if (mkdir(portal, 0660) != 0) {
+			log_error("Could not make %s: %s\n", portal,
+				  strerror(errno));
+			rc = ISCSI_ERR_IDBM;
+			goto free_portal;
+		}
+	}
+
+	rc = idbm_lock();
+	if (rc)
+		goto free_portal;
+
+	if (rec->tpgt == PORTAL_GROUP_TAG_UNKNOWN)
+		/* old style portal as config */
+		rc = idbm_rec_write_old(rec);
+	else
+		rc = idbm_rec_write_new(rec);
+
 	idbm_unlock();
 free_portal:
 	free(portal);
-- 
1.8.3.1

