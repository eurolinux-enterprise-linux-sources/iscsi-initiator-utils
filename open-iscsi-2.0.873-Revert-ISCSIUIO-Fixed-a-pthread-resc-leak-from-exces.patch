From 2c50348a9f93ef81c30d898b5ab8f1e36b927003 Mon Sep 17 00:00:00 2001
From: Chris Leech <cleech@redhat.com>
Date: Thu, 18 Aug 2016 13:06:16 -0700
Subject: [PATCH] Revert "ISCSIUIO: Fixed a pthread resc leak from excessive
 session recovery"

This reverts commit fabe160ee191fb57f826d991bcb433dd2467fdc9.
---
 iscsiuio/RELEASE.TXT           | 12 ------------
 iscsiuio/src/unix/iscsid_ipc.c | 26 +++++++++++++-------------
 iscsiuio/src/unix/main.c       |  5 +----
 iscsiuio/src/unix/nic.c        | 23 +++++++++++++++++++++--
 iscsiuio/src/unix/nic_utils.c  |  5 +----
 5 files changed, 36 insertions(+), 35 deletions(-)

diff --git a/iscsiuio/RELEASE.TXT b/iscsiuio/RELEASE.TXT
index 44d67f9..19ef717 100644
--- a/iscsiuio/RELEASE.TXT
+++ b/iscsiuio/RELEASE.TXT
@@ -11,18 +11,6 @@
                    Copyright (c) 2014, QLogic Corporation
                            All rights reserved
 
-uIP v0.7.10.2 (Feb 12, 2014)
-=======================================================
-   Fixes
-   -----
-   1. Problem: Cont00072504 - ifconfig shows allocation failure after
-               up/down few hours with iSCSI + L2 traffic
-      Cause:   A memory leak was discovered in the ongoing pthread creation
-               destruction code during the connection recovery process
-      Change:  Fixed the pthread creation code
-      Impact:  All
-
-
 uIP v0.7.8.2 (Dec 10, 2013)
 =======================================================
    Fixes
diff --git a/iscsiuio/src/unix/iscsid_ipc.c b/iscsiuio/src/unix/iscsid_ipc.c
index a2a59a8..7790dc5 100644
--- a/iscsiuio/src/unix/iscsid_ipc.c
+++ b/iscsiuio/src/unix/iscsid_ipc.c
@@ -396,9 +396,9 @@ static int parse_iface(void *arg, int do_ping)
 	char ipv6_buf_str[INET6_ADDRSTRLEN];
 	int request_type = 0;
 	struct iface_rec *rec;
+	void *res;
 	struct iface_rec_decode ird;
 	struct in_addr src_match, dst_match;
-	pthread_attr_t attr;
 	struct ping_conf *png_c;
 
 	data = (iscsid_uip_broadcast_t *) arg;
@@ -665,9 +665,7 @@ static int parse_iface(void *arg, int do_ping)
 
 	nic_iface->flags |= NIC_IFACE_PATHREQ_WAIT1;
 	if (nic->nl_process_thread == INVALID_THREAD) {
-		pthread_attr_init(&attr);
-		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-		rc = pthread_create(&nic->nl_process_thread, &attr,
+		rc = pthread_create(&nic->nl_process_thread, NULL,
 				    nl_process_handle_thread, nic);
 		if (rc != 0) {
 			LOG_ERR(PFX "%s: Could not create NIC NL "
@@ -818,16 +816,14 @@ enable_nic:
 	case NIC_STOPPED:
 		/* This thread will be thrown away when completed */
 		if (nic->enable_thread != INVALID_THREAD) {
-			rc = pthread_cancel(nic->enable_thread);
+			rc = pthread_join(nic->enable_thread, &res);
 			if (rc != 0) {
-				LOG_INFO(PFX "%s: failed to cancel enable NIC "
+				LOG_INFO(PFX "%s: failed joining enable NIC "
 					 "thread\n", nic->log_name);
 				goto eagain;
 			}
 		}
-		pthread_attr_init(&attr);
-		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-		rc = pthread_create(&nic->enable_thread, &attr,
+		rc = pthread_create(&nic->enable_thread, NULL,
 				    enable_nic_thread, (void *)nic);
 		if (rc != 0)
 			LOG_WARN(PFX "%s: failed starting enable NIC thread\n",
@@ -1169,12 +1165,9 @@ error:
  */
 int iscsid_start()
 {
-	pthread_attr_t attr;
 	int rc;
 
-	pthread_attr_init(&attr);
-	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-	rc = pthread_create(&iscsid_opts.thread, &attr, iscsid_loop, NULL);
+	rc = pthread_create(&iscsid_opts.thread, NULL, iscsid_loop, NULL);
 	if (rc != 0) {
 		LOG_ERR(PFX "Could not start iscsid listening thread rc=%d",
 			rc);
@@ -1197,6 +1190,7 @@ error:
 void iscsid_cleanup()
 {
 	int rc;
+	void *res;
 
 	if (iscsid_opts.fd != INVALID_FD) {
 		rc = pthread_cancel(iscsid_opts.thread);
@@ -1204,6 +1198,12 @@ void iscsid_cleanup()
 			LOG_ERR("Could not cancel iscsid listening thread: %s",
 				strerror(rc));
 		}
+
+		rc = pthread_join(iscsid_opts.thread, &res);
+		if (rc != 0) {
+			LOG_ERR("Could not wait for the iscsid listening "
+				"thread: %s", strerror(rc));
+		}
 	}
 
 	LOG_INFO(PFX "iscsid listening thread has shutdown");
diff --git a/iscsiuio/src/unix/main.c b/iscsiuio/src/unix/main.c
index c1a72d8..bbf8f9c 100644
--- a/iscsiuio/src/unix/main.c
+++ b/iscsiuio/src/unix/main.c
@@ -236,7 +236,6 @@ int main(int argc, char *argv[])
 	int fd;
 	int foreground = 0;
 	pid_t pid;
-	pthread_attr_t attr;
 
 	/*  Record the start time for the user space daemon */
 	opt.start_time = time(NULL);
@@ -366,9 +365,7 @@ int main(int argc, char *argv[])
 	rc = pthread_sigmask(SIG_SETMASK, &set, NULL);
 
 	/*  Spin off the signal handling thread */
-	pthread_attr_init(&attr);
-	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-	rc = pthread_create(&signal_thread, &attr, signal_handle_thread, NULL);
+	rc = pthread_create(&signal_thread, NULL, signal_handle_thread, NULL);
 	if (rc != 0)
 		LOG_ERR("Could not create signal handling thread");
 
diff --git a/iscsiuio/src/unix/nic.c b/iscsiuio/src/unix/nic.c
index 74b7c5e..0d4965d 100644
--- a/iscsiuio/src/unix/nic.c
+++ b/iscsiuio/src/unix/nic.c
@@ -465,6 +465,7 @@ int nic_remove(nic_t *nic)
 	int rc;
 	nic_t *prev, *current;
 	struct stat file_stat;
+	void *res;
 	nic_interface_t *nic_iface, *next_nic_iface, *vlan_iface;
 
 	pthread_mutex_lock(&nic->nic_mutex);
@@ -487,6 +488,12 @@ int nic_remove(nic_t *nic)
 			LOG_DEBUG(PFX "%s: Couldn't send cancel to nic enable "
 				  "thread", nic->log_name);
 
+		LOG_DEBUG(PFX "%s: Waiting to join nic enable thread",
+			  nic->log_name);
+		rc = pthread_join(nic->enable_thread, &res);
+		if (rc != 0)
+			LOG_DEBUG(PFX "%s: Couldn't join to canceled enable "
+				  "nic thread", nic->log_name);
 		nic->enable_thread = INVALID_THREAD;
 		LOG_DEBUG(PFX "%s: nic enable thread cleaned", nic->log_name);
 	} else {
@@ -502,6 +509,11 @@ int nic_remove(nic_t *nic)
 			LOG_DEBUG(PFX "%s: Couldn't send cancel to nic",
 				  nic->log_name);
 
+		LOG_DEBUG(PFX "%s: Waiting to join nic thread", nic->log_name);
+		rc = pthread_join(nic->thread, &res);
+		if (rc != 0)
+			LOG_DEBUG(PFX "%s: Couldn't join to canceled nic "
+				  "thread", nic->log_name);
 		nic->thread = INVALID_THREAD;
 		LOG_DEBUG(PFX "%s: nic thread cleaned", nic->log_name);
 	} else {
@@ -516,6 +528,12 @@ int nic_remove(nic_t *nic)
 			LOG_DEBUG(PFX "%s: Couldn't send cancel to nic nl "
 				  "thread", nic->log_name);
 
+		LOG_DEBUG(PFX "%s: Waiting to join nic nl thread",
+			  nic->log_name);
+		rc = pthread_join(nic->nl_process_thread, &res);
+		if (rc != 0)
+			LOG_DEBUG(PFX "%s: Couldn't join to canceled nic nl "
+				  "thread", nic->log_name);
 		nic->nl_process_thread = INVALID_THREAD;
 		LOG_DEBUG(PFX "%s: nic nl thread cleaned", nic->log_name);
 	} else {
@@ -1236,6 +1254,7 @@ static int do_acquisition(nic_t *nic, nic_interface_t *nic_iface,
 {
 	struct in_addr addr;
 	struct in6_addr addr6;
+	void *res;
 	char buf[INET6_ADDRSTRLEN];
 	int rc = -1;
 
@@ -1309,9 +1328,9 @@ static int do_acquisition(nic_t *nic, nic_interface_t *nic_iface,
 			if (nic->enable_thread == INVALID_THREAD)
 				goto dhcp_err;
 
-			rc = pthread_cancel(nic->enable_thread);
+			rc = pthread_join(nic->enable_thread, &res);
 			if (rc != 0)
-				LOG_ERR(PFX "%s: Couldn't cancel "
+				LOG_ERR(PFX "%s: Couldn't join to canceled "
 					"enable nic thread", nic->log_name);
 dhcp_err:
 			pthread_mutex_lock(&nic->nic_mutex);
diff --git a/iscsiuio/src/unix/nic_utils.c b/iscsiuio/src/unix/nic_utils.c
index 0daffd2..cbed986 100644
--- a/iscsiuio/src/unix/nic_utils.c
+++ b/iscsiuio/src/unix/nic_utils.c
@@ -893,7 +893,6 @@ error:
 
 void prepare_nic_thread(nic_t *nic)
 {
-	pthread_attr_t attr;
 	int rc;
 
 	pthread_mutex_lock(&nic->nic_mutex);
@@ -904,9 +903,7 @@ void prepare_nic_thread(nic_t *nic)
 		LOG_INFO(PFX "%s: spinning up thread for nic", nic->log_name);
 
 		/*  Try to spin up the nic thread */
-		pthread_attr_init(&attr);
-		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-		rc = pthread_create(&nic->thread, &attr, nic_loop, nic);
+		rc = pthread_create(&nic->thread, NULL, nic_loop, nic);
 		if (rc != 0) {
 			LOG_ERR(PFX "%s: Couldn't create thread for nic",
 				nic->log_name);
-- 
2.5.5

